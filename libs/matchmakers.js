const { combinations, shuffle } = require('../libs/utils');
const ts = require('ts-trueskill');
const auto = async(game) => {
    if (game.opts.ranked) {
        let bestQuality = -1;
        // trueskill!
        // Add indexed ids
        const
            mapped = game.members.map((x, i) => `${i}_${x.id}`),
            combos = combinations(mapped, Math.ceil(mapped.length / 2)),
            combos_splice = combos.splice(0, combos.length / 2);
        // This removes redundant unordered matching, reducing time by 2
        /*
        team = [a,b,c,d] =>
            team1 = [[a,b],[a,c],[a,d],| [b,c],[b,d],[c,d]]
            team2 = [[c,d],[b,d],[b,c],| [a,d],[a,c],[a,b]] //Generated by subtracting team1 from team
                                       ^remove from here
        */
        for (let t1 of combos_splice) {
            let t2 = mapped.filter(x => !t1.includes(x));
            t1 = t1.map(x => game.members.find(y => y.id == x.split('_')[1]));
            t2 = t2.map(x => game.members.find(y => y.id == x.split('_')[1]));
            const rate = x => new ts.Rating(x.elo.rank, x.elo.signum);
            const t1ratings = t1.map(rate), t2ratings = t2.map(rate);
            const quality = ts.quality([t1ratings, t2ratings]) || 0;
            if (quality > bestQuality) {
                bestQuality = quality;
                game.teams.alpha = new Array(...t1);
                game.teams.beta = new Array(...t2);
            }
        }
    } else {
        // Make a new array from game.members instead of refering it and then shuffle it
        const unpicked = shuffle(Array.from(game.members.map(x => x.id)));
        // Split the shuffled into two arrays and assign to alpha and beta
        [game.teams.alpha, game.teams.beta ] = new Array(Math.ceil(unpicked.length / 2))
            .fill()
            .map(() => unpicked.splice(0, 2));
    }
};

module.exports = {
    auto,
};
